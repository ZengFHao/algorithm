# 1.实验题目 

## 1.1 Matrix-chain Product 

Given the dimension of a sequence of matrices in an array arr[] , where the dimension of the ith matrix is (arr[i-1] * arr[i]) , the task is to find the most efficient way to multiply these matrices together such that the total number of element multiplications is minimum. 

## 1.2 Longest Common Subsequence 

Given two strings, S1 and S2, the task is to find the length of the longest subsequence present in both of the strings. Note: A subsequence of a string is a sequence that is generated by deleting some characters (possibly 0) from the string without altering the order of the remaining characters. For example, “abc”, “abg”, “bdf”, “aeg”, ‘”acefg”, etc are subsequences of the string “abcdefg”. 

## 1.3 Longest Common Substring 

Given two strings ‘X’ and ‘Y’, find the length of the longest common substring. 

## 1.4 Max Sum 

You are given n integers (there may be negative ones but not all) , determine i and j which maximize the sum from to . Example: (-2, 11, -4, 13, -5, 2), then i = 2 and j = 4, cause the sum ranged in that is 20 which is the maximum. 
# 2.实验目的

通过本次实验，熟悉并掌握动态规划的本质，熟悉几种DP算法

# 3.实验环境 

- OS: Windows 11 
- IDE: IDEA
- Language: Java

# 4.实验设计与分析 

## 4.1 Matrix-chain Product

对于矩阵连乘问题，首先我们应该了解到矩阵相乘的前置知识，矩阵相乘必须保证两个矩阵形如m $\times$ n，n $\times$ z，前一个矩阵确定结果矩阵的行数，第二个矩阵确定矩阵的列数，所以矩阵乘法，或者说矩阵连乘就必须要保证两个相邻矩阵的行列有一定的对应关系，于是可以将多个矩阵通过一个一维数组的形式给出。

形如：arr[10,20,50,1,100]，则表示四个矩阵ABCD。

其中：

A ：10$\times $20的矩阵

B ：20$\times $50的矩阵

C ：50$\times $1的矩阵

D ：1$\times $100的矩阵

如果我们按照A$\times $(B$\times $(C$\times $D))的顺序计算，我们需要50$\times $1$\times $100 + 20$\times $50$\times $100 + 10$\times $20$\times $100 = 125000次标量乘法。

而如果我们按照(A$\times $(B$\times $C))$\times $)的顺序计算，我们需要20$\times $50$\times $1 + 10$\times $20$\times $1 + 10$\times $1$\times $100 = 2200次标量乘法。

所以通过上述的例子我们能清晰的知道当我们能知道矩阵连乘时正确的计算顺序是能大大降低计算量来提高效率的。

### 解决方案

我们其实就是需要知道在ABCD数组中进行正确的分隔，可能是A|BCD，也有可能是AB|CD，同理还有可能是ABC|D，困难的点就是不知道这个划分的位置在哪，如果知道之后，就可以把左右两边分别进行递归求解，逐步获得最优解后在合并。既然我们不知道怎么选，那就没有办法了，其实就是需要进行穷举了，在穷举的时候，我们就需要借助于DP的思想，也就是要利用已经计算出来的子问题的答案来构造大问题的答案，通过空间来换取时间。

那我们就可以定义一个二维数组DP[i] [j]来记录从第i个矩阵到第j个矩阵的时间花费，自底向上求出AB矩阵从中间怎么划分是最优的，其实这就只有一种划分情况即是最优解，对于ABC如何进行划分，是A|BC还是AB|C，其实在第一步的时候就已经计算出了所有组合时的时间代价，这个时候A|BC和AB|C谁是最优解其实比较的就是BC和AB谁的花费更小，其实这在之前的计算中已经得出，我们只需要取更少的花费就知道ABC该如何划分，同理对于ABCD同样就能分为A|BCD, AB|CD, ABC|D，这三种情况中BCD, AB, CD, ABC也在之前的子问题计算中得到了答案，比较最小的花费就是ABCD的划分，同理继续下去就得到了如下算法：

```java
    for(int l = 2; l < len; l++){
        for(int i = 1; i < len - l + 1; i++){
            int j = i + l - 1;

            for(int k = i; k < j; k++){
                int cost = dp[i][k] + dp[k+1][j] + arr[i-1] * arr[k] * arr[j];
                if(cost < dp[i][j])
                    dp[i][j] = cost;

            }
        }
    }
    return dp[1][len - 1];
}
```

对于上述算法的时间复杂度是O(N$^3$)，虽然看上去时间复杂度是很高的，但是我们对于四个矩阵来说，O(N$^3$)的时间复杂度也没有多大，但是我们正确的划分却能把125000次标量乘法降低为2200下降的幅度是远远超过O(N$^3$)来进行合理划分的代价的，这也是我们矩阵连乘算法的意义所在、

## 4.2 Longest Common Subsequence

## 4.3 Longest Common Substring

对于这两个问题的求解我们需要知道子串和子序列之间的区别

子序列：指的是字符串中不一定连续但先后顺序一致的n个字符，即可以去掉字符串中的部分字符，但不可改变其前后顺序。

12356710子序列：12,13 ,15,16,1356,137,…

子串：指的是字符串中连续的n个字符。

abc的子串：a、 b、 c、 ab、 bc 、abc

对于上述问题的求解，首先能想到的恐怕是暴力枚举，序列A有 2^n 个子序列，序列B有 2^m 个子序列，如果任意两个子序列一一比较，比较的子序列高达 2^(n+m) 对，我们可以看出这样的暴力算法的时间复杂度是极其极其低下的，于是我们采用DP算法，我们用Ax表示序列A的连续前x项构成的子序列，即Ax= a1,a2,……ax, By= b1,b2,……by, 我们用LCS(x, y)表示它们的最长公共子序列长度，那原问题等价于求LCS(m,n)，还是和之前一样的思路我们用空间来换取时间，定义一个二维数组来表示其所有回溯可能

![image-20230426203343118](C:\Users\31783\AppData\Roaming\Typora\typora-user-images\image-20230426203343118.png)

当两个字符相等时，显然是子序列，那么只需要将计数加一，当两个字符不相同的时候，那我们就直接匹配失败？显然不是，因为子序列是可以从原字符串任意位置剔除元素，那么对于ij失配的情况我们会考虑把i剔除掉能否解决问题呢？于是就可以匹配i-1和j如果还不行就匹配i和j-1要是这都还匹配不上那就是真的匹配不上了，就去看其他元素，于是有了如下算法：

```java
for(int i = 1; i <= c1.length; i++){
    for(int j = 1; j <= c2.length; j++){
        if(c1[i-1] == c2[j-1]){
            dp[i][j] = dp[i-1][j-1] + 1;
        }else {
            dp[i][j] = Math.max(dp[i][j-1],dp[i-1][j]);
        }
    }
}
```

对于子串来说其实这和子序列的思路是一样的，无非就是子串的定义会更为严格，所以当ij失配的时候，求子序列的话由于是可以在任意位置剔除元素，所以才会比较i-1和j已经i和j-1两种情况，但是由于子串更为严苛，所以当ij失配了就真的是没有办法补救了，直接去看下一元素了，所以其实算法和子序列是一样的，只是消除了回退算法后得到如下算法：

```java
for(int i = 1; i <= c1.length; i++){
    for(int j = 1; j <= c2.length; j++){
        if(c1[i-1] == c2[j-1]){
            dp[i][j] = dp[i-1][j-1] + 1;
            max = Math.max(dp[i][j], max);
        }
    }
}
```

## 4.4 Max Sum

寻找最大子数组，这个问题其实是相对比较简单的，我们只需要定义两个变量sum记录最大子数组的和，current_sum记录当前子数组的和，首先我们将两个值都赋值为数组首元素，然后去遍历数组，我们只需要去比较current_sum所记录当前子数组的和加上当前元素和当前元素进行比较，如果current_sum所记录当前子数组的和比当前元素小了，那么显然最大之前的子数组一定不可能成为最大的子数组，因为当前的子数组加上当前元素都已经比当前元素小了，那么把其实位置改为当前元素一定会在最终的结果比之前的起始位置大，所以current_sum就不断取current_sum+当前元素和当前元素的最大值即可，sum就不断比较current_sum有没有变大，如果变大了那就重新给sum赋值即可，于是得到了如下算法：

```java
for(int i = 1; i < num.length; i++){
    sum = Math.max(sum + num[i], num[i]);
    max_sum = Math.max(max_sum, sum);
}
```

# 5.结果测试

## 5.1 Matrix-chain Product

![image-20230426205439040](C:\Users\31783\AppData\Roaming\Typora\typora-user-images\image-20230426205439040.png)

## 5.2 Longest Common Subsequence

## 5.3 Longest Common Substring

![image-20230426205318809](C:\Users\31783\AppData\Roaming\Typora\typora-user-images\image-20230426205318809.png)

## 5.4 Max Sum

![image-20230426205510252](C:\Users\31783\AppData\Roaming\Typora\typora-user-images\image-20230426205510252.png)

# 6.实验总结

在本次实验中，其实最开始的时候对于矩阵连乘的算法求解的时候，由于最开始是没有DP的基础，所以在刚开始的时候对于DP的理解恨不到位，也就导致求解第一个问题花费了大量的时间，但是经过了本次的实验之后，我已经熟悉并逐步掌握了如何利用DP来进行问题的求解，这是我本次实验的最大收获
